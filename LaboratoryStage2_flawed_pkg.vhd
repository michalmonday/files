---------------------------------------------------
-- Sheet: Laboratory Stage 2
-- RefDes: 
-- Part Number: XC7A35T
-- Generated By: Multisim
--
-- Author: mb19424
-- Date: Thursday, November 07 13:15:59, 2019
---------------------------------------------------

---------------------------------------------------
-- Use: This file contains definitions of components
-- Use with the exported top-level file
---------------------------------------------------
library ieee;
use ieee.std_logic_1164.ALL;
use ieee.numeric_std.ALL;

package LaboratoryStage2_pkg is

	component AND4_NI
		port (
    D : in STD_LOGIC := 'X';
    C : in STD_LOGIC := 'X';
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
	end component;

	component AUTO_IBUF
		port(
		I : in std_logic;
		O : out std_logic
	);
	end component;

	component AUTO_OBUF
		port(
		I : in std_logic;
		O : out std_logic
	);
	end component;

	component BUF_NI
		port (
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
	end component;

	component CNTR_4BIN_S_NI
		port( 
  LOAD: in STD_LOGIC;
  CLR: in STD_LOGIC;
  ENP: in STD_LOGIC; 
  ENT: in STD_LOGIC;
  CLK: in STD_LOGIC;
  A :in STD_LOGIC;
  B :in STD_LOGIC;
  C :in STD_LOGIC;
  D :in STD_LOGIC;
  RCO : out STD_LOGIC;
  QA : out STD_LOGIC;
  QB : out STD_LOGIC;
  QC : out STD_LOGIC;
  QD : out STD_LOGIC
 );
	end component;

	component CNTR_7BIN_NI
		Port ( 
   MR : in  STD_LOGIC;
   CP : in  STD_LOGIC;
   Q1 : out  STD_LOGIC;
   Q2 : out  STD_LOGIC;
   Q3 : out  STD_LOGIC;
   Q4 : out  STD_LOGIC;
   Q5 : out  STD_LOGIC;
   Q6 : out  STD_LOGIC;
   Q7 : out  STD_LOGIC
 );
	end component;

	component CNTR_BCD_S_NI
		port( 
  LOAD: in std_logic;
  CLR: in std_logic;
  ENP: in std_logic; 
  ENT: in std_logic;
  CLK: in std_logic;
  A:in STD_LOGIC;
  B:in STD_LOGIC;
  C:in STD_LOGIC;
  D:in STD_LOGIC;
  RCO: out STD_LOGIC;
  QA: out STD_LOGIC;
  QB: out STD_LOGIC;
  QC: out STD_LOGIC;
  QD: out STD_LOGIC
 );
	end component;

	component COMP_4_NI
		port (
   B3 : in STD_LOGIC := 'X';
   B2 : in STD_LOGIC := 'X';
   B1 : in STD_LOGIC := 'X';
   B0 : in STD_LOGIC := 'X';
   A3 : in STD_LOGIC := 'X';
   A2 : in STD_LOGIC := 'X';
   A1 : in STD_LOGIC := 'X';
   A0 : in STD_LOGIC := 'X';
   AGTB : in STD_LOGIC := 'X';
   AEQB : in STD_LOGIC := 'X';
   ALTB : in STD_LOGIC := 'X';
   OAGTB : out STD_LOGIC := 'U';
   OAEQB : out STD_LOGIC := 'U';
   OALTB : out STD_LOGIC := 'U'
    );
	end component;

	component DIGITAL_HIGH_NI
		Port ( 
  Y : out  STD_LOGIC:='1'
 );
	end component;

	component DIGITAL_LOW_NI
		Port ( 
  Y : out  STD_LOGIC:='0'
 );
	end component;

	component FF_D_CO_NI
		Port ( D : in  STD_LOGIC;
           CLK : in  STD_LOGIC;
           Q : out  STD_LOGIC;
           Qneg : out  STD_LOGIC);
	end component;

	component FF_JK_PSCLR_CO_NI
		port (
   J: in STD_LOGIC;
   K: in STD_LOGIC;
   CLK : in STD_LOGIC;  
   PR: in STD_LOGIC;
   CLR: in STD_LOGIC;
   Q : out STD_LOGIC;
   Qneg : out STD_LOGIC
);
	end component;

	component OR2_NI
		port (
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
	end component;

end LaboratoryStage2_pkg;
package body LaboratoryStage2_pkg is
end LaboratoryStage2_pkg;


library work;
use work.LaboratoryStage2_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity AND4_NI is
  port (
    D : in STD_LOGIC := 'X';
    C : in STD_LOGIC := 'X';
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
end AND4_NI;

architecture BEHAVIORAL of AND4_NI is  

begin
  Y <= (A and B and C and D);
end BEHAVIORAL;

library work;
use work.LaboratoryStage2_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.all;

entity AUTO_IBUF is
	port(
		I : in std_logic;
		O : out std_logic
	);end AUTO_IBUF;

architecture AUTO_IBUF_ARCH of AUTO_IBUF is

begin
 O <= I;
end AUTO_IBUF_ARCH;


library work;
use work.LaboratoryStage2_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.all;

entity AUTO_OBUF is
	port(
		I : in std_logic;
		O : out std_logic
	);end AUTO_OBUF;

architecture AUTO_OBUF_ARCH of AUTO_OBUF is

begin
 O <= I;
end AUTO_OBUF_ARCH;


library work;
use work.LaboratoryStage2_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity BUF_NI is
  port (
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
end BUF_NI;

architecture BEHAVIORAL of BUF_NI is  

begin
  Y <= A;
end BEHAVIORAL;

library work;
use work.LaboratoryStage2_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity CNTR_4BIN_S_NI is
 port( 
  LOAD: in STD_LOGIC;
  CLR: in STD_LOGIC;
  ENP: in STD_LOGIC; 
  ENT: in STD_LOGIC;
  CLK: in STD_LOGIC;
  A :in STD_LOGIC;
  B :in STD_LOGIC;
  C :in STD_LOGIC;
  D :in STD_LOGIC;
  RCO : out STD_LOGIC;
  QA : out STD_LOGIC;
  QB : out STD_LOGIC;
  QC : out STD_LOGIC;
  QD : out STD_LOGIC
 );
end CNTR_4BIN_S_NI;

architecture BEHAVIORAL of CNTR_4BIN_S_NI is
signal Q: STD_LOGIC_VECTOR(3 downto 0);

begin
 RCO<=Q(3) and Q(2) and Q(1) and Q(0) and ENT;
 process
 begin
   wait until CLK='1';
   if CLR = '0' then Q<="0000";
     elsif LOAD='0' then Q<=D&C&B&A;
     elsif (ENP and ENT)='1' then
     Q<=Q+"0001";
  end if;
 end process;
 QD<=Q(3);
 QC<=Q(2);
 QB<=Q(1);
 QA<=Q(0);
end BEHAVIORAL;

library work;
use work.LaboratoryStage2_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity CNTR_7BIN_NI is
 Port ( 
   MR : in  STD_LOGIC;
   CP : in  STD_LOGIC;
   Q1 : out  STD_LOGIC;
   Q2 : out  STD_LOGIC;
   Q3 : out  STD_LOGIC;
   Q4 : out  STD_LOGIC;
   Q5 : out  STD_LOGIC;
   Q6 : out  STD_LOGIC;
   Q7 : out  STD_LOGIC
 );
end CNTR_7BIN_NI;

architecture BEHAVIORAL of CNTR_7BIN_NI is
signal Y: STD_LOGIC_VECTOR(7 downto 1):="0000000";
begin

 process (CP,MR)
 begin
 if MR = '1' then Y<="0000000";		
  elsif falling_edge(CP) then
        Y<=Y+"0000001";
 end if;
 end process;
 Q1<=Y(1);
 Q2<=Y(2);
 Q3<=Y(3);
 Q4<=Y(4);
 Q5<=Y(5);
 Q6<=Y(6);
 Q7<=Y(7);
end BEHAVIORAL;

library work;
use work.LaboratoryStage2_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity CNTR_BCD_S_NI is
 port( 
  LOAD: in std_logic;
  CLR: in std_logic;
  ENP: in std_logic; 
  ENT: in std_logic;
  CLK: in std_logic;
  A:in STD_LOGIC;
  B:in STD_LOGIC;
  C:in STD_LOGIC;
  D:in STD_LOGIC;
  RCO: out STD_LOGIC;
  QA: out STD_LOGIC;
  QB: out STD_LOGIC;
  QC: out STD_LOGIC;
  QD: out STD_LOGIC
 );
end CNTR_BCD_S_NI;

architecture BEHAVIORAL of CNTR_BCD_S_NI is
signal Q: STD_LOGIC_VECTOR(3 downto 0);

begin
 process
 begin
 wait until CLK='1';
  if CLR = '0' then Q<="0000";
	             RCO<='0';
  elsif LOAD='0' then Q<=D&C&B&A;
		  RCO<='0';
  elsif (ENP and ENT)='1' then
   if Q="1000" then 
		RCO<='1';
		Q<=Q+"0001";
   elsif Q="1001" then 
		Q<="0000";
		RCO<='0';
   else
		Q<=Q+"0001";
		RCO<='0';
   end if;
  end if;
 end process;
 QD<=Q(3);
 QC<=Q(2);
 QB<=Q(1);
 QA<=Q(0);	
end BEHAVIORAL;

library work;
use work.LaboratoryStage2_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity COMP_4_NI is
  port (
   B3 : in STD_LOGIC := 'X';
   B2 : in STD_LOGIC := 'X';
   B1 : in STD_LOGIC := 'X';
   B0 : in STD_LOGIC := 'X';
   A3 : in STD_LOGIC := 'X';
   A2 : in STD_LOGIC := 'X';
   A1 : in STD_LOGIC := 'X';
   A0 : in STD_LOGIC := 'X';
   AGTB : in STD_LOGIC := 'X';
   AEQB : in STD_LOGIC := 'X';
   ALTB : in STD_LOGIC := 'X';
   OAGTB : out STD_LOGIC := 'U';
   OAEQB : out STD_LOGIC := 'U';
   OALTB : out STD_LOGIC := 'U'
    );
end COMP_4_NI;

architecture BEHAVIORAL of COMP_4_NI is  
begin
PROCESS (A0, B0, A1, A2, A3, B1, B2, B3, AGTB, AEQB, ALTB)
     BEGIN
  if A3>B3 then OAGTB<='1';
                         OAEQB<='0';
	          OALTB<='0';
        elsif A3<B3 then OAGTB<='0';
                                   OAEQB<='0';
	                    OALTB<='1';	
          elsif A3=B3 then
            if A2>B2 then OAGTB<='1';
                                   OAEQB<='0';
		    OALTB<='0'; 
              elsif A2<B2 then OAGTB<='0';
                                         OAEQB<='0';
		          OALTB<='1';	
                elsif A2=B2 then
                  if A1>B1 then OAGTB<='1';
                                         OAEQB<='0';
		          OALTB<='0'; 
                    elsif A1<B1 then OAGTB<='0';
                                               OAEQB<='0';
			OALTB<='1';		
                      elsif A1=B1 then
                          if A0>B0 then OAGTB<='1';
                                                  OAEQB<='0';
			  OALTB<='0'; 
                            elsif A0<B0 then OAGTB<='0';
                                                       OAEQB<='0';
			        OALTB<='1';	
              		 elsif A0=B0 then
                                    if AGTB='1' and AEQB='0' and ALTB='0' then OAGTB<='1';
                                                                                                            OAEQB<='0';
				                                             OALTB<='0'; 
		          elsif ALTB='1' and AEQB='0' and AGTB='1' then OAGTB<='0';
			   				      OAEQB<='0';
							       OALTB<='0';	
                                              elsif AEQB='1' and AGTB='0' and ALTB='0' then OAGTB<='0';
							          OAEQB<='1';
							          OALTB<='0'; 
		                 elsif ALTB='1' and AEQB='0' and AGTB='0' then OAGTB<='0';
                                                                                                                             OAEQB<='0';
				                                                              OALTB<='1';   
                                               elsif AEQB='1' then 	OAGTB<='0';
					OAEQB<='1';
					OALTB<='0';  
                                                     elsif ALTB='0' and AEQB='0' and AGTB='0' then  OAGTB<='1';
                                                                                                                                  OAEQB<='0';
				                                                                   OALTB<='1';  	
										
						end if;
					end if;
				end if;
			end if;
end if;																							
END PROCESS;
end BEHAVIORAL;

library work;
use work.LaboratoryStage2_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity DIGITAL_HIGH_NI is
 Port ( 
  Y : out  STD_LOGIC:='1'
 );
end DIGITAL_HIGH_NI;

architecture BEHAVIORAL of DIGITAL_HIGH_NI is
begin
 Y<='1';
end BEHAVIORAL;

library work;
use work.LaboratoryStage2_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity DIGITAL_LOW_NI is
 Port ( 
  Y : out  STD_LOGIC:='0'
 );
end DIGITAL_LOW_NI;

architecture BEHAVIORAL of DIGITAL_LOW_NI is
begin
 Y<='0';
end BEHAVIORAL;

library work;
use work.LaboratoryStage2_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity FF_D_CO_NI is
    Port ( D : in  STD_LOGIC;
           CLK : in  STD_LOGIC;
           Q : out  STD_LOGIC;
           Qneg : out  STD_LOGIC);
end FF_D_CO_NI;

architecture BEHAVIORAL of FF_D_CO_NI is

begin
 process (CLK,D)
 begin
  if rising_edge(CLK) then
    if D='1' then Q<='1';
	         Qneg<='0';
	else Q<='0';
	       Qneg<='1';           
    end if;
  end if;
 end process;		
end BEHAVIORAL;

library work;
use work.LaboratoryStage2_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity FF_JK_PSCLR_CO_NI is
  port (
   J: in STD_LOGIC;
   K: in STD_LOGIC;
   CLK : in STD_LOGIC;  
   PR: in STD_LOGIC;
   CLR: in STD_LOGIC;
   Q : out STD_LOGIC;
   Qneg : out STD_LOGIC
);
end FF_JK_PSCLR_CO_NI;

architecture BEHAVIORAL of FF_JK_PSCLR_CO_NI is  
signal Qnot: STD_LOGIC:='0';
signal Qpos: STD_LOGIC:='1';

begin
  process (CLK,PR,CLR)
  begin
      if (PR='0' and CLR='1') then  Qpos<='1';
                                                       Qnot<='0';
          elsif (PR='1' and CLR='0') then Qpos<='0';
                                                              Qnot<='1'; 
          elsif (PR='0' and CLR='0') then Qpos<='1';
                                                               Qnot<='1';
          elsif (CLK'event and CLK='1') then
	    if (J='1' and K='1') then Qpos<=Qnot;
		                           Qnot<=Qpos;	
                    elsif (J='0' and K='1') then Qpos<='0';
		                               Qnot<='1';	
	    elsif (J='1' and K='0') then Qpos<='1';
			               Qnot<='0';							  
	    end if;
           end if;
 end process;		
 Qneg<=Qnot;
 Q<=Qpos;
end BEHAVIORAL;

library work;
use work.LaboratoryStage2_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity OR2_NI is
  port (
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
end OR2_NI;

architecture BEHAVIORAL of OR2_NI is  

begin
  Y <= A or B;
end BEHAVIORAL;
